/*
	Ben Davis
	1/11/23
	EE 371
	Lab 2, Task 2
	
	This module counts up to 15 for the 32x4 RAM. 
	It takes in three inputs, a reset, a plus one (inc), and
	a minus one (dec). It returns the number of cars in the lot
	as a 4 bit output (out).
	
*/

module counter_15 (clk, rst, inc, dec, out);

	input logic clk, rst; //clock, reset
	output logic [3:0] out; //read address for ram
	
	enum {s0, s1, s2, s3, s4, s5, s6, s7, s8 //states for rdaddress
			, s9, s10, s11, s12, s13, s14, s15} ps, ns;
	
	//always ff block to reset the state to zero
	//or to move to the next state if need be
	always_ff @(posedge clk) begin
		if(rst) begin
			ps <= s0;
		end else begin
			ps <= ns;
		end
	end
	
	//assigning each bit. each bit is one in specific states
	// example: first bit is only true in odd states
	assign out[0] = ((ps==s1)|(ps==s3)|(ps==s5)|(ps==s7)|(ps==s9)|
							(ps==s11)|(ps==s13)|(ps==s15));
							
	assign out[1] = ((ps==s2)|(ps==s3)|(ps==s6)|(ps==s7)|(ps==s10)|(ps==s11)|
							(ps==s14)|(ps==s15));
							
	assign out[2] = ((ps==s4)|(ps==s5)|(ps==s6)|(ps==s7)|(ps==s12)|(ps==s13)|(ps==s14)|
							(ps==s15));
							
	assign out[3] = ((ps==s8)|(ps==s9)|(ps==s10)|(ps==s11)|(ps==s12)|(ps==s13)|
							(ps==s14)|(ps==s15));
	
	//this is a counter, each state will go to the next state
	always_comb begin
		case(ps)
		
			s0: ns <= s1;
					
			s1: ns <= s2;
					
					
			s2: ns <= s3;
					
					
			s3: ns <= s4;
					
					
			s4: ns <= s5;
					
					
			s5: ns <= s6;
					
					
			s6: ns <= s7;
					
					
			s7: ns <= s8;
					
					
			s8: ns <= s9;
					
					
			s9: ns <= s10;
					
					
			s10: ns <= s11;
					
					
			s11: ns <= s12;
					
					
			s12: ns <= s13;
					
					
			s13: ns <= s14;
					
					
			s14: ns <= s15;
					
					
			s15: ns <= s0;
					
		endcase
	end
endmodule
	
module counter_21_testbench();

	logic clk, rst; //repeating logic variables
	logic [3:0] out;
	
	//test counter_25 module
	counter_25 dut (.clk, .rst, .out);
	
	// clock setup
	parameter clock_period = 100;
	
	initial begin
		clk <= 0;
		forever #(clock_period /2) clk = ~clk;
	end // of clock setup
	
	//an instance where it counts up to five with a
	//space after the first increment, and then
	//decrements twice
	initial begin
		rst <= 0;  @(posedge clk);
		rst <= 0;  @(posedge clk);
		rst <= 0;  @(posedge clk);
		rst <= 0;  @(posedge clk);
		rst <= 0;  @(posedge clk);
		rst <= 0;  @(posedge clk);
		rst <= 0;  @(posedge clk);
		rst <= 0;  @(posedge clk);
		$stop;
	end
endmodule 